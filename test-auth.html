<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Auth Tests</title>
  <style>
    body { font-family: monospace; background: #0a0a0a; color: #e0e0e0; padding: 24px; }
    h1 { color: #f59e0b; margin-bottom: 16px; }
    .suite { margin-bottom: 24px; }
    .suite-title { color: #9ca3af; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .test { padding: 6px 10px; margin: 3px 0; border-radius: 4px; font-size: 14px; }
    .pass { color: #22c55e; background: rgba(34,197,94,0.08); }
    .fail { color: #ef4444; background: rgba(239,68,68,0.08); }
    .detail { font-size: 11px; color: #6b7280; margin-top: 2px; }
    .summary { margin-top: 24px; font-size: 18px; font-weight: bold; }
    .summary.all-pass { color: #22c55e; }
    .summary.has-fail { color: #ef4444; }
    .loading { color: #6b7280; }
  </style>
</head>
<body>
  <h1>Auth Tests</h1>
  <div id="output"><p class="loading">Tests werden ausgeführt…</p></div>

  <script type="module">
    const suites = [];
    let currentSuite = null;

    function suite(name) {
      currentSuite = { name, tests: [] };
      suites.push(currentSuite);
    }

    function test(name, passed, detail = '') {
      currentSuite.tests.push({ name, passed, detail });
    }

    // Timestamp-Query-Parameter → SW-Cache umgehen
    // (caches.match() findet keinen Treffer für neue URL → Netzwerk-Fetch)
    const ts = Date.now();
    const [authSrc, appSrc, swSrc] = await Promise.all([
      fetch(`/js/auth.js?_=${ts}`).then(r => r.text()),
      fetch(`/js/app.js?_=${ts}`).then(r => r.text()),
      fetch(`/sw.js?_=${ts}`).then(r => r.text()),
    ]);

    // ─── Suite 1: auth.js — Popup-first mit iOS-PWA-Fallback ─────────────────
    suite('auth.js — Popup-first, Redirect nur für iOS PWA Standalone');

    test(
      'signInWithPopup ist importiert',
      authSrc.includes('signInWithPopup'),
      'Import muss in firebase-auth.js vorhanden sein'
    );
    test(
      'signInWithRedirect ist importiert (iOS-PWA-Fallback)',
      authSrc.includes('signInWithRedirect'),
      'Redirect-Import muss für iOS-PWA-Fallback vorhanden sein'
    );
    test(
      'isIOSPWA() erkennt iOS PWA via navigator.standalone',
      authSrc.includes('navigator.standalone === true') &&
      authSrc.includes('/iPhone|iPad|iPod/i.test(navigator.userAgent)'),
      'Beide Bedingungen müssen kombiniert geprüft werden'
    );
    test(
      'iOS PWA → signInWithRedirect',
      /isIOSPWA\(\)[\s\S]*?signInWithRedirect/.test(authSrc),
      'Im isIOSPWA()-Branch muss signInWithRedirect aufgerufen werden'
    );
    test(
      'Alle anderen Plattformen → signInWithPopup',
      (() => {
        const start = authSrc.indexOf('export async function signInWithGoogle');
        const end   = authSrc.indexOf('\nexport', start + 1);
        const fn    = authSrc.slice(start, end > -1 ? end : undefined);
        const returns = [...fn.matchAll(/return\s+(\w+)\(/g)].map(m => m[1]);
        return returns.includes('signInWithPopup');
      })(),
      'Der Default-Branch (nicht iOS-PWA) muss signInWithPopup verwenden'
    );

    // ─── Suite 2: app.js — Boot-Reihenfolge ──────────────────────────────────
    suite('app.js — Boot-Reihenfolge');

    const bootFn      = appSrc.slice(appSrc.indexOf('async function boot()'));
    const redirectIdx = bootFn.indexOf('getRedirectResult(auth)');
    const gateIdx     = bootFn.indexOf('initAccessGate()');
    const listenerIdx = bootFn.indexOf('onAuthStateChanged(auth');

    test(
      'getRedirectResult() wird VOR initAccessGate() aufgerufen',
      redirectIdx < gateIdx,
      `getRedirectResult bei Zeichen ${redirectIdx}, initAccessGate bei ${gateIdx}`
    );
    test(
      'initAccessGate() wird VOR onAuthStateChanged() aufgerufen',
      gateIdx < listenerIdx,
      `initAccessGate bei ${gateIdx}, onAuthStateChanged bei ${listenerIdx}`
    );
    test(
      'Unlock-Key wird gesetzt wenn getRedirectResult ein Ergebnis liefert',
      bootFn.includes("localStorage.setItem(ACCESS_UNLOCKED_KEY, 'true')") &&
      bootFn.indexOf("localStorage.setItem(ACCESS_UNLOCKED_KEY, 'true')") < gateIdx,
      'setItem muss im getRedirectResult-Block vor initAccessGate stehen'
    );
    test(
      'Unlock-Key wird im Google-Button-Handler gesetzt (vor Redirect)',
      (() => {
        const btnBlock = appSrc.slice(
          appSrc.indexOf("googleSignInBtn.addEventListener('click'"),
          appSrc.indexOf('signInWithGoogle(auth)')
        );
        return btnBlock.includes("localStorage.setItem(ACCESS_UNLOCKED_KEY, 'true')");
      })(),
      'Sicherheitsnetz: Key ist gesetzt bevor der Browser navigiert'
    );

    // ─── Suite 3: Gemockter Redirect/Popup-Flow ───────────────────────────────
    suite('Auth-Flow (gemockt)');

    const UNLOCK_KEY = 'todotobe-access-unlocked-TEST';

    // Test A: getRedirectResult liefert User → Key wird gesetzt
    localStorage.removeItem(UNLOCK_KEY);
    const mockResult = { user: { uid: 'mock-uid', email: 'test@example.com' } };
    if (mockResult) localStorage.setItem(UNLOCK_KEY, 'true');
    test(
      'getRedirectResult mit User → Unlock-Key wird gesetzt',
      localStorage.getItem(UNLOCK_KEY) === 'true',
      'Nach erfolgreichem Redirect muss ACCESS_UNLOCKED_KEY gesetzt sein'
    );

    // Test B: Popup-Ergebnis + Button-Handler setzt Key vor Auth
    localStorage.removeItem(UNLOCK_KEY);
    localStorage.setItem(UNLOCK_KEY, 'true'); // simuliert Button-Click
    const nullResult = null;
    if (nullResult) localStorage.setItem(UNLOCK_KEY, 'true');
    test(
      'onAuthStateChanged lässt User durch wenn Key vor Auth gesetzt wurde',
      localStorage.getItem(UNLOCK_KEY) === 'true',
      'Button-Handler setzt Key vor signInWithPopup/Redirect'
    );

    // Test C: Ohne Key → User wird abgewiesen
    localStorage.removeItem(UNLOCK_KEY);
    test(
      'Ohne Unlock-Key → User wird abgewiesen (Sicherheit)',
      localStorage.getItem(UNLOCK_KEY) !== 'true',
      'Wenn Key fehlt, soll onAuthStateChanged signOut aufrufen'
    );

    // Test D: isIOSPWA()-Logik (simuliert, da navigator.standalone im Test-Browser false ist)
    const simulatedIOSPWA = (() => {
      const ua = 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15';
      const standaloneTrue = true;
      return /iPhone|iPad|iPod/i.test(ua) && standaloneTrue === true;
    })();
    test(
      'isIOSPWA()-Logik: iPhone + standalone=true → true',
      simulatedIOSPWA === true,
      'Simulierter iOS-PWA-Kontext muss true ergeben'
    );

    const simulatedNonPWA = (() => {
      const ua = 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15';
      const standaloneFalse = false;
      return /iPhone|iPad|iPod/i.test(ua) && standaloneFalse === true;
    })();
    test(
      'isIOSPWA()-Logik: iPhone + standalone=false → false (normaler Safari)',
      simulatedNonPWA === false,
      'Normaler iOS-Safari (kein Homescreen) darf nicht als PWA erkannt werden'
    );

    const simulatedAndroid = (() => {
      const ua = 'Mozilla/5.0 (Linux; Android 13) Chrome/120';
      const standaloneUndef = undefined;
      return /iPhone|iPad|iPod/i.test(ua) && standaloneUndef === true;
    })();
    test(
      'isIOSPWA()-Logik: Android → false (bekommt Popup)',
      simulatedAndroid === false,
      'Android nutzt navigator.standalone nicht → kein Redirect nötig'
    );

    localStorage.removeItem(UNLOCK_KEY);

    // ─── Suite 4: Service Worker ──────────────────────────────────────────────
    suite('sw.js — Firebase Auth nicht gecacht');

    const neverCacheStart = swSrc.indexOf('Never cache Firebase');
    const neverCacheEnd   = swSrc.indexOf('Cache-first for same-origin');
    const neverCacheBlock = swSrc.slice(neverCacheStart, neverCacheEnd);
    const staleBlock      = swSrc.slice(swSrc.indexOf('Stale-while-revalidate'));

    test(
      'firebaseapp.com ist im never-cache Block',
      neverCacheBlock.includes('firebaseapp.com'),
      'Auth-Iframe darf nie vom SW gecacht werden'
    );
    test(
      '/__/auth/ Pfade sind im never-cache Block',
      neverCacheBlock.includes('/__/auth/'),
      'Alle Firebase-Auth-Endpunkte müssen pass-through sein'
    );
    test(
      'firebaseapp.com ist NICHT im stale-while-revalidate Block',
      !staleBlock.includes('firebaseapp.com'),
      'Wurde aus dem falsch konfigurierten Block entfernt'
    );
    test(
      'SW-Cache ist auf v11 gebumpt',
      swSrc.includes("'todotobe-v11'"),
      'Alte gecachte Auth-Einträge werden damit gelöscht'
    );

    // ─── Ergebnis rendern ─────────────────────────────────────────────────────
    const allTests = suites.flatMap(s => s.tests);
    const passed   = allTests.filter(t => t.passed).length;
    const total    = allTests.length;
    const allPass  = passed === total;

    document.getElementById('output').innerHTML = `
      ${suites.map(s => `
        <div class="suite">
          <div class="suite-title">${s.name}</div>
          ${s.tests.map(t => `
            <div class="test ${t.passed ? 'pass' : 'fail'}">
              ${t.passed ? '✓' : '✗'} ${t.name}
              ${t.detail ? `<div class="detail">${t.detail}</div>` : ''}
            </div>
          `).join('')}
        </div>
      `).join('')}
      <div class="summary ${allPass ? 'all-pass' : 'has-fail'}">
        ${allPass ? '✓ Alle Tests bestanden' : `✗ ${total - passed} von ${total} Tests fehlgeschlagen`}
        (${passed}/${total})
      </div>
    `;
  </script>
</body>
</html>
